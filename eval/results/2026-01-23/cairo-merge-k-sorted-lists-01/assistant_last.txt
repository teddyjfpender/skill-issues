{"code":"use core::array::{Array, ArrayTrait};\n\nfn merge_two_sorted<\n    T,\n    impl TDrop: Drop<T>,\n    impl TCopy: Copy<T>,\n    impl TPartialOrd: PartialOrd<T>,\n>(left: @Array<T>, right: @Array<T>) -> Array<T> {\n    let mut result: Array<T> = ArrayTrait::new();\n    let mut i: usize = 0;\n    let mut j: usize = 0;\n    let left_len = left.len();\n    let right_len = right.len();\n\n    while i < left_len && j < right_len {\n        let left_value = *left[i];\n        let right_value = *right[j];\n        if left_value <= right_value {\n            result.append(left_value);\n            i += 1;\n        } else {\n            result.append(right_value);\n            j += 1;\n        }\n    }\n\n    while i < left_len {\n        result.append(*left[i]);\n        i += 1;\n    }\n\n    while j < right_len {\n        result.append(*right[j]);\n        j += 1;\n    }\n\n    result\n}\n\nfn merge_k_sorted_generic<\n    T,\n    impl TDrop: Drop<T>,\n    impl TCopy: Copy<T>,\n    impl TPartialOrd: PartialOrd<T>,\n>(lists: @Array<Array<T>>) -> Array<T> {\n    let mut result: Array<T> = ArrayTrait::new();\n    let mut i: usize = 0;\n    let lists_len = lists.len();\n\n    while i < lists_len {\n        let merged = merge_two_sorted(@result, lists[i]);\n        result = merged;\n        i += 1;\n    }\n\n    result\n}\n\npub fn merge_k_sorted(lists: Array<Array<i32>>) -> Array<i32> {\n    merge_k_sorted_generic(@lists)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::merge_k_sorted;\n    use core::array::{Array, ArrayTrait};\n\n    fn assert_array_eq(expected: @Array<i32>, actual: @Array<i32>, label: felt252) {\n        let expected_len = expected.len();\n        let actual_len = actual.len();\n        assert!(expected_len == actual_len, label);\n        let mut i: usize = 0;\n        while i < expected_len {\n            assert!(*expected[i] == *actual[i], label);\n            i += 1;\n        }\n    }\n\n    #[test]\n    fn merge_normal() {\n        let mut list1: Array<i32> = ArrayTrait::new();\n        list1.append(1_i32);\n        list1.append(4_i32);\n        list1.append(5_i32);\n\n        let mut list2: Array<i32> = ArrayTrait::new();\n        list2.append(1_i32);\n        list2.append(3_i32);\n        list2.append(4_i32);\n\n        let mut list3: Array<i32> = ArrayTrait::new();\n        list3.append(2_i32);\n        list3.append(6_i32);\n\n        let mut lists: Array<Array<i32>> = ArrayTrait::new();\n        lists.append(list1);\n        lists.append(list2);\n        lists.append(list3);\n\n        let merged = merge_k_sorted(lists);\n\n        let mut expected: Array<i32> = ArrayTrait::new();\n        expected.append(1_i32);\n        expected.append(1_i32);\n        expected.append(2_i32);\n        expected.append(3_i32);\n        expected.append(4_i32);\n        expected.append(4_i32);\n        expected.append(5_i32);\n        expected.append(6_i32);\n\n        assert_array_eq(@expected, @merged, \"normal merge\");\n    }\n\n    #[test]\n    fn merge_empty_input() {\n        let lists: Array<Array<i32>> = ArrayTrait::new();\n        let merged = merge_k_sorted(lists);\n        let expected: Array<i32> = ArrayTrait::new();\n        assert_array_eq(@expected, @merged, \"empty input\");\n    }\n\n    #[test]\n    fn merge_with_empty_arrays() {\n        let empty1: Array<i32> = ArrayTrait::new();\n        let empty2: Array<i32> = ArrayTrait::new();\n\n        let mut list: Array<i32> = ArrayTrait::new();\n        list.append(2_i32);\n        list.append(3_i32);\n\n        let mut lists: Array<Array<i32>> = ArrayTrait::new();\n        lists.append(empty1);\n        lists.append(list);\n        lists.append(empty2);\n\n        let merged = merge_k_sorted(lists);\n\n        let mut expected: Array<i32> = ArrayTrait::new();\n        expected.append(2_i32);\n        expected.append(3_i32);\n\n        assert_array_eq(@expected, @merged, \"empty arrays\");\n    }\n\n    #[test]\n    fn merge_single_array() {\n        let mut list: Array<i32> = ArrayTrait::new();\n        list.append(7_i32);\n        list.append(9_i32);\n        list.append(10_i32);\n\n        let mut lists: Array<Array<i32>> = ArrayTrait::new();\n        lists.append(list);\n\n        let merged = merge_k_sorted(lists);\n\n        let mut expected: Array<i32> = ArrayTrait::new();\n        expected.append(7_i32);\n        expected.append(9_i32);\n        expected.append(10_i32);\n\n        assert_array_eq(@expected, @merged, \"single array\");\n    }\n\n    #[test]\n    fn merge_with_duplicates() {\n        let mut list1: Array<i32> = ArrayTrait::new();\n        list1.append(1_i32);\n        list1.append(2_i32);\n        list1.append(2_i32);\n\n        let mut list2: Array<i32> = ArrayTrait::new();\n        list2.append(2_i32);\n        list2.append(2_i32);\n\n        let mut lists: Array<Array<i32>> = ArrayTrait::new();\n        lists.append(list1);\n        lists.append(list2);\n\n        let merged = merge_k_sorted(lists);\n\n        let mut expected: Array<i32> = ArrayTrait::new();\n        expected.append(1_i32);\n        expected.append(2_i32);\n        expected.append(2_i32);\n        expected.append(2_i32);\n        expected.append(2_i32);\n\n        assert_array_eq(@expected, @merged, \"duplicates\");\n    }\n}\n","notes":"Requested skills $cairo-arrays, $cairo-generics-traits, and $cairo-control-flow are not available in the provided skill list, so I proceeded without them. Tests not run."}