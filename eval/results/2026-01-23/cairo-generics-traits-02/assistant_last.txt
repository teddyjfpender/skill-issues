{"code":"use core::array::{Array, ArrayTrait};\n\n#[derive(Drop)]\nstruct MinStack<T> {\n    stack: Array<T>,\n    mins: Array<T>,\n}\n\ntrait MinStackTrait<T> {\n    fn new() -> MinStack<T>;\n    fn push(ref self: MinStack<T>, value: T);\n    fn pop(ref self: MinStack<T>) -> Option<T>;\n    fn peek(self: @MinStack<T>) -> Option<T>;\n    fn get_min(self: @MinStack<T>) -> Option<T>;\n    fn is_empty(self: @MinStack<T>) -> bool;\n}\n\nfn pop_back_array<T, impl TDrop: Drop<T>, impl TCopy: Copy<T>>(ref arr: Array<T>) -> Option<T> {\n    let len = arr.len();\n    if len == 0 {\n        return None;\n    }\n\n    let last = *(@arr[len - 1]);\n    let mut new_arr: Array<T> = ArrayTrait::new();\n    let mut i: usize = 0;\n    while i + 1 < len {\n        new_arr.append(*(@arr[i]));\n        i += 1;\n    }\n    arr = new_arr;\n    Some(last)\n}\n\nimpl MinStackImpl<\n    T,\n    impl TDrop: Drop<T>,\n    impl TCopy: Copy<T>,\n    impl TPartialOrd: PartialOrd<T>,\n    impl TPartialEq: PartialEq<T>,\n> of MinStackTrait<T> {\n    fn new() -> MinStack<T> {\n        MinStack { stack: ArrayTrait::new(), mins: ArrayTrait::new() }\n    }\n\n    fn push(ref self: MinStack<T>, value: T) {\n        if self.mins.is_empty() {\n            self.mins.append(value);\n        } else {\n            let current_min = *(@self.mins[self.mins.len() - 1]);\n            if value <= current_min {\n                self.mins.append(value);\n            }\n        }\n\n        self.stack.append(value);\n    }\n\n    fn pop(ref self: MinStack<T>) -> Option<T> {\n        let value = pop_back_array(ref self.stack)?;\n\n        if !self.mins.is_empty() {\n            let current_min = *(@self.mins[self.mins.len() - 1]);\n            if value == current_min {\n                let _ = pop_back_array(ref self.mins);\n            }\n        }\n\n        Some(value)\n    }\n\n    fn peek(self: @MinStack<T>) -> Option<T> {\n        if self.stack.is_empty() {\n            return None;\n        }\n\n        Some(*(@self.stack[self.stack.len() - 1]))\n    }\n\n    fn get_min(self: @MinStack<T>) -> Option<T> {\n        if self.mins.is_empty() {\n            return None;\n        }\n\n        Some(*(@self.mins[self.mins.len() - 1]))\n    }\n\n    fn is_empty(self: @MinStack<T>) -> bool {\n        self.stack.is_empty()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{MinStack, MinStackTrait};\n\n    #[test]\n    fn min_stack_push_pop_min() {\n        let mut stack: MinStack<u32> = MinStackTrait::new();\n        assert!(stack.is_empty(), \"new stack should be empty\");\n        assert!(stack.get_min() == None, \"min should be None on empty\");\n        assert!(stack.peek() == None, \"peek should be None on empty\");\n        assert!(stack.pop() == None, \"pop should be None on empty\");\n\n        stack.push(3);\n        assert!(stack.get_min() == Some(3), \"min after pushing 3\");\n\n        stack.push(5);\n        assert!(stack.get_min() == Some(3), \"min stays 3 after pushing 5\");\n\n        stack.push(2);\n        assert!(stack.get_min() == Some(2), \"min becomes 2 after pushing 2\");\n\n        stack.push(2);\n        assert!(stack.get_min() == Some(2), \"min stays 2 with duplicate\");\n\n        stack.push(4);\n        assert!(stack.get_min() == Some(2), \"min stays 2 after pushing 4\");\n        assert!(stack.peek() == Some(4), \"peek returns top element\");\n\n        assert!(stack.pop() == Some(4), \"pop returns 4\");\n        assert!(stack.get_min() == Some(2), \"min still 2 after popping 4\");\n\n        assert!(stack.pop() == Some(2), \"pop duplicate min\");\n        assert!(stack.get_min() == Some(2), \"min still 2 due to remaining duplicate\");\n\n        assert!(stack.pop() == Some(2), \"pop last min\");\n        assert!(stack.get_min() == Some(3), \"min updates to 3\");\n\n        assert!(stack.pop() == Some(5), \"pop 5\");\n        assert!(stack.get_min() == Some(3), \"min remains 3\");\n\n        assert!(stack.pop() == Some(3), \"pop 3\");\n        assert!(stack.get_min() == None, \"min None after empty\");\n        assert!(stack.is_empty(), \"stack empty after popping all\");\n        assert!(stack.pop() == None, \"pop None when empty\");\n        assert!(stack.peek() == None, \"peek None when empty\");\n    }\n}\n","notes":"Requested skill $cairo-generics-traits was not available in AGENTS.md; proceeded without it. Tried `scarb build` but it failed due to permission error opening the Scarb registry cache lock (/Users/theodorepender/Library/Caches/com.swmansion.scarb/registry/cache/scarbs.xyz-9djtpev4jug5q.v1.redb.lock) while downloading snforge_scarb_plugin v0.55.0."}