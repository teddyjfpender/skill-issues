{"code":"const TWO_POW_64: u128 = 0x1_0000_0000_0000_0000_u128;\n\n#[derive(Copy, Drop)]\npub struct U256 {\n    limb0: u64,\n    limb1: u64,\n    limb2: u64,\n    limb3: u64,\n}\n\n#[derive(Copy, Drop)]\npub struct I256 {\n    mag: U256,\n    neg: bool,\n}\n\npub type i256 = I256;\n\n#[derive(Copy, Drop)]\npub struct SQ128x128 {\n    pub raw: i256,\n}\n\nconst U256_ZERO: U256 = U256 { limb0: 0_u64, limb1: 0_u64, limb2: 0_u64, limb3: 0_u64 };\nconst U256_ONE: U256 = U256 { limb0: 1_u64, limb1: 0_u64, limb2: 0_u64, limb3: 0_u64 };\nconst U256_SCALE: U256 = U256 { limb0: 0_u64, limb1: 0_u64, limb2: 1_u64, limb3: 0_u64 };\nconst U256_MAX_POS_MAG: U256 = U256 {\n    limb0: 0xffff_ffff_ffff_ffff_u64,\n    limb1: 0xffff_ffff_ffff_ffff_u64,\n    limb2: 0xffff_ffff_ffff_ffff_u64,\n    limb3: 0x7fff_ffff_ffff_ffff_u64,\n};\nconst U256_MAX_NEG_MAG: U256 = U256 {\n    limb0: 0_u64,\n    limb1: 0_u64,\n    limb2: 0_u64,\n    limb3: 0x8000_0000_0000_0000_u64,\n};\n\nconst I256_ZERO: I256 = I256 { mag: U256_ZERO, neg: false };\nconst I256_ONE: I256 = I256 { mag: U256_ONE, neg: false };\nconst I256_NEG_ONE: I256 = I256 { mag: U256_ONE, neg: true };\nconst I256_SCALE: I256 = I256 { mag: U256_SCALE, neg: false };\nconst I256_NEG_SCALE: I256 = I256 { mag: U256_SCALE, neg: true };\nconst I256_MIN: I256 = I256 { mag: U256_MAX_NEG_MAG, neg: true };\nconst I256_MAX: I256 = I256 { mag: U256_MAX_POS_MAG, neg: false };\n\npub const ZERO: SQ128x128 = SQ128x128 { raw: I256_ZERO };\npub const ONE: SQ128x128 = SQ128x128 { raw: I256_SCALE };\npub const NEG_ONE: SQ128x128 = SQ128x128 { raw: I256_NEG_SCALE };\npub const MIN: SQ128x128 = SQ128x128 { raw: I256_MIN };\npub const MAX: SQ128x128 = SQ128x128 { raw: I256_MAX };\npub const ONE_ULP: SQ128x128 = SQ128x128 { raw: I256_ONE };\n\n#[derive(Copy, Drop)]\nstruct U512 {\n    limb0: u64,\n    limb1: u64,\n    limb2: u64,\n    limb3: u64,\n    limb4: u64,\n    limb5: u64,\n    limb6: u64,\n    limb7: u64,\n}\n\nfn u256_zero() -> U256 {\n    U256_ZERO\n}\n\nfn u256_is_zero(value: U256) -> bool {\n    value.limb0 == 0_u64 && value.limb1 == 0_u64 && value.limb2 == 0_u64 && value.limb3 == 0_u64\n}\n\nfn u256_cmp(a: U256, b: U256) -> i32 {\n    if a.limb3 < b.limb3 {\n        return -1_i32;\n    }\n    if a.limb3 > b.limb3 {\n        return 1_i32;\n    }\n    if a.limb2 < b.limb2 {\n        return -1_i32;\n    }\n    if a.limb2 > b.limb2 {\n        return 1_i32;\n    }\n    if a.limb1 < b.limb1 {\n        return -1_i32;\n    }\n    if a.limb1 > b.limb1 {\n        return 1_i32;\n    }\n    if a.limb0 < b.limb0 {\n        return -1_i32;\n    }\n    if a.limb0 > b.limb0 {\n        return 1_i32;\n    }\n    0_i32\n}\n\nfn u256_eq(a: U256, b: U256) -> bool {\n    a.limb0 == b.limb0 && a.limb1 == b.limb1 && a.limb2 == b.limb2 && a.limb3 == b.limb3\n}\n\nfn u128_from_u64(value: u64) -> u128 {\n    value.into()\n}\n\nfn u64_from_u128(value: u128) -> u64 {\n    value.try_into().unwrap()\n}\n\nfn add_u64_with_carry(a: u64, b: u64, carry: u64) -> (u64, u64) {\n    let sum: u128 = u128_from_u64(a) + u128_from_u64(b) + u128_from_u64(carry);\n    let low: u128 = sum % TWO_POW_64;\n    let high: u128 = sum / TWO_POW_64;\n    (u64_from_u128(low), u64_from_u128(high))\n}\n\nfn sub_u64_with_borrow(a: u64, b: u64, borrow: u64) -> (u64, u64) {\n    let a128: u128 = u128_from_u64(a);\n    let b128: u128 = u128_from_u64(b) + u128_from_u64(borrow);\n    if a128 >= b128 {\n        let diff: u128 = a128 - b128;\n        return (u64_from_u128(diff), 0_u64);\n    }\n    let diff: u128 = (TWO_POW_64 + a128) - b128;\n    (u64_from_u128(diff), 1_u64)\n}\n\nfn u256_add(a: U256, b: U256) -> (U256, bool) {\n    let (l0, c0) = add_u64_with_carry(a.limb0, b.limb0, 0_u64);\n    let (l1, c1) = add_u64_with_carry(a.limb1, b.limb1, c0);\n    let (l2, c2) = add_u64_with_carry(a.limb2, b.limb2, c1);\n    let (l3, c3) = add_u64_with_carry(a.limb3, b.limb3, c2);\n    (\n        U256 { limb0: l0, limb1: l1, limb2: l2, limb3: l3 },\n        c3 != 0_u64,\n    )\n}\n\nfn u256_add_u64(a: U256, value: u64) -> (U256, bool) {\n    let (l0, c0) = add_u64_with_carry(a.limb0, value, 0_u64);\n    let (l1, c1) = add_u64_with_carry(a.limb1, 0_u64, c0);\n    let (l2, c2) = add_u64_with_carry(a.limb2, 0_u64, c1);\n    let (l3, c3) = add_u64_with_carry(a.limb3, 0_u64, c2);\n    (\n        U256 { limb0: l0, limb1: l1, limb2: l2, limb3: l3 },\n        c3 != 0_u64,\n    )\n}\n\nfn u256_sub(a: U256, b: U256) -> (U256, bool) {\n    let (l0, b0) = sub_u64_with_borrow(a.limb0, b.limb0, 0_u64);\n    let (l1, b1) = sub_u64_with_borrow(a.limb1, b.limb1, b0);\n    let (l2, b2) = sub_u64_with_borrow(a.limb2, b.limb2, b1);\n    let (l3, b3) = sub_u64_with_borrow(a.limb3, b.limb3, b2);\n    (\n        U256 { limb0: l0, limb1: l1, limb2: l2, limb3: l3 },\n        b3 != 0_u64,\n    )\n}\n\nfn u128_split_to_u64(value: u128) -> (u64, u64) {\n    let low: u128 = value % TWO_POW_64;\n    let high: u128 = value / TWO_POW_64;\n    (u64_from_u128(low), u64_from_u128(high))\n}\n\nfn u512_zero() -> U512 {\n    U512 {\n        limb0: 0_u64,\n        limb1: 0_u64,\n        limb2: 0_u64,\n        limb3: 0_u64,\n        limb4: 0_u64,\n        limb5: 0_u64,\n        limb6: 0_u64,\n        limb7: 0_u64,\n    }\n}\n\nfn u512_add_one_from(mut acc: U512, start: u8) -> U512 {\n    if start == 0_u8 {\n        let (l0, c0) = add_u64_with_carry(acc.limb0, 0_u64, 1_u64);\n        acc.limb0 = l0;\n        if c0 == 0_u64 {\n            return acc;\n        }\n        let (l1, c1) = add_u64_with_carry(acc.limb1, 0_u64, 1_u64);\n        acc.limb1 = l1;\n        if c1 == 0_u64 {\n            return acc;\n        }\n        let (l2, c2) = add_u64_with_carry(acc.limb2, 0_u64, 1_u64);\n        acc.limb2 = l2;\n        if c2 == 0_u64 {\n            return acc;\n        }\n        let (l3, c3) = add_u64_with_carry(acc.limb3, 0_u64, 1_u64);\n        acc.limb3 = l3;\n        if c3 == 0_u64 {\n            return acc;\n        }\n        let (l4, c4) = add_u64_with_carry(acc.limb4, 0_u64, 1_u64);\n        acc.limb4 = l4;\n        if c4 == 0_u64 {\n            return acc;\n        }\n        let (l5, c5) = add_u64_with_carry(acc.limb5, 0_u64, 1_u64);\n        acc.limb5 = l5;\n        if c5 == 0_u64 {\n            return acc;\n        }\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 1_u8 {\n        let (l1, c1) = add_u64_with_carry(acc.limb1, 0_u64, 1_u64);\n        acc.limb1 = l1;\n        if c1 == 0_u64 {\n            return acc;\n        }\n        let (l2, c2) = add_u64_with_carry(acc.limb2, 0_u64, 1_u64);\n        acc.limb2 = l2;\n        if c2 == 0_u64 {\n            return acc;\n        }\n        let (l3, c3) = add_u64_with_carry(acc.limb3, 0_u64, 1_u64);\n        acc.limb3 = l3;\n        if c3 == 0_u64 {\n            return acc;\n        }\n        let (l4, c4) = add_u64_with_carry(acc.limb4, 0_u64, 1_u64);\n        acc.limb4 = l4;\n        if c4 == 0_u64 {\n            return acc;\n        }\n        let (l5, c5) = add_u64_with_carry(acc.limb5, 0_u64, 1_u64);\n        acc.limb5 = l5;\n        if c5 == 0_u64 {\n            return acc;\n        }\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 2_u8 {\n        let (l2, c2) = add_u64_with_carry(acc.limb2, 0_u64, 1_u64);\n        acc.limb2 = l2;\n        if c2 == 0_u64 {\n            return acc;\n        }\n        let (l3, c3) = add_u64_with_carry(acc.limb3, 0_u64, 1_u64);\n        acc.limb3 = l3;\n        if c3 == 0_u64 {\n            return acc;\n        }\n        let (l4, c4) = add_u64_with_carry(acc.limb4, 0_u64, 1_u64);\n        acc.limb4 = l4;\n        if c4 == 0_u64 {\n            return acc;\n        }\n        let (l5, c5) = add_u64_with_carry(acc.limb5, 0_u64, 1_u64);\n        acc.limb5 = l5;\n        if c5 == 0_u64 {\n            return acc;\n        }\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 3_u8 {\n        let (l3, c3) = add_u64_with_carry(acc.limb3, 0_u64, 1_u64);\n        acc.limb3 = l3;\n        if c3 == 0_u64 {\n            return acc;\n        }\n        let (l4, c4) = add_u64_with_carry(acc.limb4, 0_u64, 1_u64);\n        acc.limb4 = l4;\n        if c4 == 0_u64 {\n            return acc;\n        }\n        let (l5, c5) = add_u64_with_carry(acc.limb5, 0_u64, 1_u64);\n        acc.limb5 = l5;\n        if c5 == 0_u64 {\n            return acc;\n        }\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 4_u8 {\n        let (l4, c4) = add_u64_with_carry(acc.limb4, 0_u64, 1_u64);\n        acc.limb4 = l4;\n        if c4 == 0_u64 {\n            return acc;\n        }\n        let (l5, c5) = add_u64_with_carry(acc.limb5, 0_u64, 1_u64);\n        acc.limb5 = l5;\n        if c5 == 0_u64 {\n            return acc;\n        }\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 5_u8 {\n        let (l5, c5) = add_u64_with_carry(acc.limb5, 0_u64, 1_u64);\n        acc.limb5 = l5;\n        if c5 == 0_u64 {\n            return acc;\n        }\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 6_u8 {\n        let (l6, c6) = add_u64_with_carry(acc.limb6, 0_u64, 1_u64);\n        acc.limb6 = l6;\n        if c6 == 0_u64 {\n            return acc;\n        }\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    if start == 7_u8 {\n        let (l7, c7) = add_u64_with_carry(acc.limb7, 0_u64, 1_u64);\n        acc.limb7 = l7;\n        assert!(c7 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    assert!(false, \"u512 overflow\");\n    acc\n}\n\nfn u512_add_product(acc: U512, a: u64, b: u64, idx: u8) -> U512 {\n    let prod: u128 = u128_from_u64(a) * u128_from_u64(b);\n    let (low, high) = u128_split_to_u64(prod);\n    let mut acc = acc;\n    if idx == 0_u8 {\n        let (l0, c0) = add_u64_with_carry(acc.limb0, low, 0_u64);\n        acc.limb0 = l0;\n        let (l1, c1) = add_u64_with_carry(acc.limb1, high, c0);\n        acc.limb1 = l1;\n        if c1 == 1_u64 {\n            acc = u512_add_one_from(acc, 2_u8);\n        }\n        return acc;\n    }\n    if idx == 1_u8 {\n        let (l1, c0) = add_u64_with_carry(acc.limb1, low, 0_u64);\n        acc.limb1 = l1;\n        let (l2, c1) = add_u64_with_carry(acc.limb2, high, c0);\n        acc.limb2 = l2;\n        if c1 == 1_u64 {\n            acc = u512_add_one_from(acc, 3_u8);\n        }\n        return acc;\n    }\n    if idx == 2_u8 {\n        let (l2, c0) = add_u64_with_carry(acc.limb2, low, 0_u64);\n        acc.limb2 = l2;\n        let (l3, c1) = add_u64_with_carry(acc.limb3, high, c0);\n        acc.limb3 = l3;\n        if c1 == 1_u64 {\n            acc = u512_add_one_from(acc, 4_u8);\n        }\n        return acc;\n    }\n    if idx == 3_u8 {\n        let (l3, c0) = add_u64_with_carry(acc.limb3, low, 0_u64);\n        acc.limb3 = l3;\n        let (l4, c1) = add_u64_with_carry(acc.limb4, high, c0);\n        acc.limb4 = l4;\n        if c1 == 1_u64 {\n            acc = u512_add_one_from(acc, 5_u8);\n        }\n        return acc;\n    }\n    if idx == 4_u8 {\n        let (l4, c0) = add_u64_with_carry(acc.limb4, low, 0_u64);\n        acc.limb4 = l4;\n        let (l5, c1) = add_u64_with_carry(acc.limb5, high, c0);\n        acc.limb5 = l5;\n        if c1 == 1_u64 {\n            acc = u512_add_one_from(acc, 6_u8);\n        }\n        return acc;\n    }\n    if idx == 5_u8 {\n        let (l5, c0) = add_u64_with_carry(acc.limb5, low, 0_u64);\n        acc.limb5 = l5;\n        let (l6, c1) = add_u64_with_carry(acc.limb6, high, c0);\n        acc.limb6 = l6;\n        if c1 == 1_u64 {\n            acc = u512_add_one_from(acc, 7_u8);\n        }\n        return acc;\n    }\n    if idx == 6_u8 {\n        let (l6, c0) = add_u64_with_carry(acc.limb6, low, 0_u64);\n        acc.limb6 = l6;\n        let (l7, c1) = add_u64_with_carry(acc.limb7, high, c0);\n        acc.limb7 = l7;\n        assert!(c1 == 0_u64, \"u512 overflow\");\n        return acc;\n    }\n    assert!(false, \"u512 overflow\");\n    acc\n}\n\nfn u256_mul(a: U256, b: U256) -> U512 {\n    let mut acc = u512_zero();\n    acc = u512_add_product(acc, a.limb0, b.limb0, 0_u8);\n    acc = u512_add_product(acc, a.limb0, b.limb1, 1_u8);\n    acc = u512_add_product(acc, a.limb0, b.limb2, 2_u8);\n    acc = u512_add_product(acc, a.limb0, b.limb3, 3_u8);\n\n    acc = u512_add_product(acc, a.limb1, b.limb0, 1_u8);\n    acc = u512_add_product(acc, a.limb1, b.limb1, 2_u8);\n    acc = u512_add_product(acc, a.limb1, b.limb2, 3_u8);\n    acc = u512_add_product(acc, a.limb1, b.limb3, 4_u8);\n\n    acc = u512_add_product(acc, a.limb2, b.limb0, 2_u8);\n    acc = u512_add_product(acc, a.limb2, b.limb1, 3_u8);\n    acc = u512_add_product(acc, a.limb2, b.limb2, 4_u8);\n    acc = u512_add_product(acc, a.limb2, b.limb3, 5_u8);\n\n    acc = u512_add_product(acc, a.limb3, b.limb0, 3_u8);\n    acc = u512_add_product(acc, a.limb3, b.limb1, 4_u8);\n    acc = u512_add_product(acc, a.limb3, b.limb2, 5_u8);\n    acc = u512_add_product(acc, a.limb3, b.limb3, 6_u8);\n    acc\n}\n\nfn u512_high_overflow(value: U512) -> bool {\n    value.limb6 != 0_u64 || value.limb7 != 0_u64\n}\n\nfn u512_remainder_nonzero(value: U512) -> bool {\n    value.limb0 != 0_u64 || value.limb1 != 0_u64\n}\n\nfn u512_shr_128(value: U512) -> U256 {\n    U256 { limb0: value.limb2, limb1: value.limb3, limb2: value.limb4, limb3: value.limb5 }\n}\n\nfn i256_normalize(value: I256) -> I256 {\n    if u256_is_zero(value.mag) {\n        return I256 { mag: value.mag, neg: false };\n    }\n    value\n}\n\nfn i256_is_zero(value: I256) -> bool {\n    u256_is_zero(value.mag)\n}\n\nfn i256_eq(a: I256, b: I256) -> bool {\n    a.neg == b.neg && u256_eq(a.mag, b.mag)\n}\n\nfn i256_cmp(a: I256, b: I256) -> i32 {\n    if a.neg != b.neg {\n        if a.neg {\n            return -1_i32;\n        }\n        return 1_i32;\n    }\n    if !a.neg {\n        return u256_cmp(a.mag, b.mag);\n    }\n    -u256_cmp(a.mag, b.mag)\n}\n\nfn i128_abs_to_u128(value: i128) -> (u128, bool) {\n    if value >= 0_i128 {\n        let magnitude: u128 = value.try_into().unwrap();\n        return (magnitude, false);\n    }\n    let plus_one: i128 = value + 1_i128;\n    let mag_minus_one: u128 = (-plus_one).try_into().unwrap();\n    (mag_minus_one + 1_u128, true)\n}\n\nfn u256_from_u128_shifted_128(value: u128) -> U256 {\n    let (low, high) = u128_split_to_u64(value);\n    U256 { limb0: 0_u64, limb1: 0_u64, limb2: low, limb3: high }\n}\n\nfn i256_add_internal(a: I256, b: I256) -> I256 {\n    if a.neg == b.neg {\n        let (sum, overflow) = u256_add(a.mag, b.mag);\n        assert!(!overflow, \"i256 add overflow\");\n        if a.neg {\n            assert!(u256_cmp(sum, U256_MAX_NEG_MAG) <= 0_i32, \"i256 add overflow\");\n        } else {\n            assert!(u256_cmp(sum, U256_MAX_POS_MAG) <= 0_i32, \"i256 add overflow\");\n        }\n        return i256_normalize(I256 { mag: sum, neg: a.neg });\n    }\n\n    let cmp = u256_cmp(a.mag, b.mag);\n    if cmp == 0_i32 {\n        return I256_ZERO;\n    }\n    if cmp > 0_i32 {\n        let (diff, underflow) = u256_sub(a.mag, b.mag);\n        assert!(!underflow, \"i256 add underflow\");\n        return i256_normalize(I256 { mag: diff, neg: a.neg });\n    }\n    let (diff, underflow) = u256_sub(b.mag, a.mag);\n    assert!(!underflow, \"i256 add underflow\");\n    i256_normalize(I256 { mag: diff, neg: b.neg })\n}\n\nfn i256_sub_internal(a: I256, b: I256) -> I256 {\n    if b.neg {\n        if a.neg {\n            let cmp = u256_cmp(a.mag, b.mag);\n            if cmp == 0_i32 {\n                return I256_ZERO;\n            }\n            if cmp > 0_i32 {\n                let (diff, underflow) = u256_sub(a.mag, b.mag);\n                assert!(!underflow, \"i256 sub underflow\");\n                return i256_normalize(I256 { mag: diff, neg: true });\n            }\n            let (diff, underflow) = u256_sub(b.mag, a.mag);\n            assert!(!underflow, \"i256 sub underflow\");\n            return i256_normalize(I256 { mag: diff, neg: false });\n        }\n\n        let (sum, overflow) = u256_add(a.mag, b.mag);\n        assert!(!overflow, \"i256 sub overflow\");\n        assert!(u256_cmp(sum, U256_MAX_POS_MAG) <= 0_i32, \"i256 sub overflow\");\n        return i256_normalize(I256 { mag: sum, neg: false });\n    }\n\n    if a.neg {\n        let (sum, overflow) = u256_add(a.mag, b.mag);\n        assert!(!overflow, \"i256 sub overflow\");\n        assert!(u256_cmp(sum, U256_MAX_NEG_MAG) <= 0_i32, \"i256 sub overflow\");\n        return i256_normalize(I256 { mag: sum, neg: true });\n    }\n\n    let cmp = u256_cmp(a.mag, b.mag);\n    if cmp == 0_i32 {\n        return I256_ZERO;\n    }\n    if cmp > 0_i32 {\n        let (diff, underflow) = u256_sub(a.mag, b.mag);\n        assert!(!underflow, \"i256 sub underflow\");\n        return i256_normalize(I256 { mag: diff, neg: false });\n    }\n    let (diff, underflow) = u256_sub(b.mag, a.mag);\n    assert!(!underflow, \"i256 sub underflow\");\n    i256_normalize(I256 { mag: diff, neg: true })\n}\n\npub fn from_raw(raw: i256) -> SQ128x128 {\n    SQ128x128 { raw: i256_normalize(raw) }\n}\n\npub fn to_raw(value: SQ128x128) -> i256 {\n    value.raw\n}\n\npub fn from_int(value: i128) -> SQ128x128 {\n    let (mag128, neg) = i128_abs_to_u128(value);\n    let mag = u256_from_u128_shifted_128(mag128);\n    let raw = i256_normalize(I256 { mag, neg });\n    if neg {\n        assert!(u256_cmp(raw.mag, U256_MAX_NEG_MAG) <= 0_i32, \"from_int overflow\");\n    } else {\n        assert!(u256_cmp(raw.mag, U256_MAX_POS_MAG) <= 0_i32, \"from_int overflow\");\n    }\n    SQ128x128 { raw }\n}\n\nfn add_internal(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    SQ128x128 { raw: i256_add_internal(a.raw, b.raw) }\n}\n\nfn sub_internal(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    SQ128x128 { raw: i256_sub_internal(a.raw, b.raw) }\n}\n\npub fn add(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    add_internal(a, b)\n}\n\npub fn sub(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    sub_internal(a, b)\n}\n\npub fn delta(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    sub_internal(b, a)\n}\n\nfn mul_internal(a: SQ128x128, b: SQ128x128, round_up: bool) -> SQ128x128 {\n    if i256_is_zero(a.raw) || i256_is_zero(b.raw) {\n        return ZERO;\n    }\n    let neg = a.raw.neg != b.raw.neg;\n    let product = u256_mul(a.raw.mag, b.raw.mag);\n    assert!(!u512_high_overflow(product), \"mul overflow\");\n    let mut mag = u512_shr_128(product);\n    let rem_nonzero = u512_remainder_nonzero(product);\n\n    if neg {\n        if !round_up && rem_nonzero {\n            let (inc, overflow) = u256_add_u64(mag, 1_u64);\n            assert!(!overflow, \"mul overflow\");\n            mag = inc;\n        }\n        assert!(u256_cmp(mag, U256_MAX_NEG_MAG) <= 0_i32, \"mul overflow\");\n        return SQ128x128 { raw: i256_normalize(I256 { mag, neg: true }) };\n    }\n\n    if round_up && rem_nonzero {\n        let (inc, overflow) = u256_add_u64(mag, 1_u64);\n        assert!(!overflow, \"mul overflow\");\n        mag = inc;\n    }\n    assert!(u256_cmp(mag, U256_MAX_POS_MAG) <= 0_i32, \"mul overflow\");\n    SQ128x128 { raw: i256_normalize(I256 { mag, neg: false }) }\n}\n\npub fn mul_down(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    mul_internal(a, b, false)\n}\n\npub fn mul_up(a: SQ128x128, b: SQ128x128) -> SQ128x128 {\n    mul_internal(a, b, true)\n}\n\nimpl SQ128x128PartialEq of PartialEq<SQ128x128> {\n    fn eq(lhs: SQ128x128, rhs: SQ128x128) -> bool {\n        i256_eq(lhs.raw, rhs.raw)\n    }\n}\n\nimpl SQ128x128PartialOrd of PartialOrd<SQ128x128> {\n    fn lt(lhs: SQ128x128, rhs: SQ128x128) -> bool {\n        i256_cmp(lhs.raw, rhs.raw) < 0_i32\n    }\n\n    fn le(lhs: SQ128x128, rhs: SQ128x128) -> bool {\n        i256_cmp(lhs.raw, rhs.raw) <= 0_i32\n    }\n\n    fn gt(lhs: SQ128x128, rhs: SQ128x128) -> bool {\n        i256_cmp(lhs.raw, rhs.raw) > 0_i32\n    }\n\n    fn ge(lhs: SQ128x128, rhs: SQ128x128) -> bool {\n        i256_cmp(lhs.raw, rhs.raw) >= 0_i32\n    }\n}\n\nimpl SQ128x128Add of Add<SQ128x128> {\n    fn add(lhs: SQ128x128, rhs: SQ128x128) -> SQ128x128 {\n        add_internal(lhs, rhs)\n    }\n}\n\nimpl SQ128x128Sub of Sub<SQ128x128> {\n    fn sub(lhs: SQ128x128, rhs: SQ128x128) -> SQ128x128 {\n        sub_internal(lhs, rhs)\n    }\n}\n\nimpl SQ128x128Mul of Mul<SQ128x128> {\n    fn mul(lhs: SQ128x128, rhs: SQ128x128) -> SQ128x128 {\n        mul_internal(lhs, rhs, false)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        add, delta, from_int, from_raw, mul_down, mul_up, sub, I256, ONE, ONE_ULP, SQ128x128, ZERO,\n        MAX, MIN, NEG_ONE,\n    };\n\n    fn raw_from_limbs(l0: u64, l1: u64, l2: u64, l3: u64, neg: bool) -> I256 {\n        I256 { mag: super::U256 { limb0: l0, limb1: l1, limb2: l2, limb3: l3 }, neg }\n    }\n\n    #[test]\n    fn constants_raw_values() {\n        let zero = ZERO;\n        assert!(super::i256_eq(zero.raw, super::I256_ZERO), \"ZERO raw\");\n\n        let one = ONE;\n        let expected_one = raw_from_limbs(0_u64, 0_u64, 1_u64, 0_u64, false);\n        assert!(super::i256_eq(one.raw, expected_one), \"ONE raw\");\n\n        let neg_one = super::NEG_ONE;\n        let expected_neg_one = raw_from_limbs(0_u64, 0_u64, 1_u64, 0_u64, true);\n        assert!(super::i256_eq(neg_one.raw, expected_neg_one), \"NEG_ONE raw\");\n\n        let min = MIN;\n        let expected_min =\n            raw_from_limbs(0_u64, 0_u64, 0_u64, 0x8000_0000_0000_0000_u64, true);\n        assert!(super::i256_eq(min.raw, expected_min), \"MIN raw\");\n\n        let max = MAX;\n        let expected_max = raw_from_limbs(\n            0xffff_ffff_ffff_ffff_u64,\n            0xffff_ffff_ffff_ffff_u64,\n            0xffff_ffff_ffff_ffff_u64,\n            0x7fff_ffff_ffff_ffff_u64,\n            false,\n        );\n        assert!(super::i256_eq(max.raw, expected_max), \"MAX raw\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn add_overflow_max_plus_one_ulp() {\n        let _ = add(MAX, ONE_ULP);\n    }\n\n    #[test]\n    #[should_panic]\n    fn sub_overflow_min_minus_one_ulp() {\n        let _ = sub(MIN, ONE_ULP);\n    }\n\n    #[test]\n    fn add_max_plus_neg_max_is_zero() {\n        let neg_max = SQ128x128 { raw: I256 { mag: MAX.raw.mag, neg: true } };\n        let sum = add(MAX, neg_max);\n        assert!(sum == ZERO, \"max + neg_max == zero\");\n    }\n\n    #[test]\n    #[should_panic]\n    fn add_min_plus_min_overflows() {\n        let _ = add(MIN, MIN);\n    }\n\n    #[test]\n    fn delta_zero_when_same() {\n        let value = from_int(7_i128);\n        let d = delta(value, value);\n        assert!(d == ZERO, \"delta(a,a) == zero\");\n    }\n\n    #[test]\n    fn delta_round_trip() {\n        let a = from_int(-3_i128);\n        let b = from_int(5_i128);\n        let d = delta(a, b);\n        let sum = add(a, d);\n        assert!(sum == b, \"a + delta(a,b) == b\");\n    }\n\n    #[test]\n    fn mul_one_identities() {\n        let values = [MIN, NEG_ONE, ZERO, ONE, MAX];\n        let mut i: usize = 0;\n        while i < 5 {\n            let v = values[i];\n            assert!(mul_down(ONE, v) == v, \"one * v mul_down\");\n            assert!(mul_down(v, ONE) == v, \"v * one mul_down\");\n            assert!(mul_up(ONE, v) == v, \"one * v mul_up\");\n            assert!(mul_up(v, ONE) == v, \"v * one mul_up\");\n            i += 1;\n        }\n    }\n\n    #[test]\n    fn mul_neg_one_identities() {\n        assert!(mul_down(NEG_ONE, NEG_ONE) == ONE, \"neg_one * neg_one down\");\n        assert!(mul_up(NEG_ONE, NEG_ONE) == ONE, \"neg_one * neg_one up\");\n        assert!(mul_down(NEG_ONE, ONE) == NEG_ONE, \"neg_one * one down\");\n        assert!(mul_up(NEG_ONE, ONE) == NEG_ONE, \"neg_one * one up\");\n    }\n\n    #[test]\n    fn mul_rounding_positive_remainder() {\n        let a = from_raw(raw_from_limbs(3_u64, 0_u64, 0_u64, 0_u64, false));\n        let b = from_raw(raw_from_limbs(1_u64, 0_u64, 0_u64, 0_u64, false));\n        let down = mul_down(a, b);\n        let up = mul_up(a, b);\n        assert!(down == ZERO, \"mul_down truncates\");\n        assert!(up == ONE_ULP, \"mul_up rounds\");\n        let diff = sub(up, down);\n        assert!(diff == ZERO || diff == ONE_ULP, \"diff is 0 or 1\");\n    }\n\n    #[test]\n    fn mul_rounding_negative_remainder() {\n        let a = from_raw(raw_from_limbs(3_u64, 0_u64, 0_u64, 0_u64, true));\n        let b = from_raw(raw_from_limbs(1_u64, 0_u64, 0_u64, 0_u64, false));\n        let down = mul_down(a, b);\n        let up = mul_up(a, b);\n        let expected_down = from_raw(raw_from_limbs(1_u64, 0_u64, 0_u64, 0_u64, true));\n        assert!(down == expected_down, \"mul_down floors negative\");\n        assert!(up == ZERO, \"mul_up ceilings negative\");\n        let diff = sub(up, down);\n        assert!(diff == ONE_ULP, \"diff is 1\");\n    }\n}\n","notes":"Skills used: cairo-structs, cairo-operator-overloading, cairo-data-types, cairo-traits, cairo-testing (structs/traits/operators/types/tests). Implemented i256 as sign+magnitude (alias) because Cairo lacks native i256 in this setup. Build/test not run: scarb failed accessing /Users/theodorepender/Library/Caches and SCARB_CACHE override triggered a scarb panic in system-configuration."}