#!/usr/bin/env bun
/**
 * Starknet Contract TypeScript Binding Generator
 *
 * Generates TypeScript types and provider classes from contract ABIs.
 *
 * Usage:
 *   bun run generate.ts <contract_class.json> [output_dir]
 *
 * Example:
 *   bun run generate.ts ./target/dev/hello_contract_HelloStarknet.contract_class.json ./bindings
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from "fs";
import { basename, dirname, join } from "path";

// ABI type definitions
interface AbiFunction {
  type: "function";
  name: string;
  inputs: Array<{ name: string; type: string }>;
  outputs: Array<{ type: string }>;
  state_mutability: "view" | "external";
}

interface AbiInterface {
  type: "interface";
  name: string;
  items: AbiFunction[];
}

interface AbiImpl {
  type: "impl";
  name: string;
  interface_name: string;
}

interface AbiEvent {
  type: "event";
  name: string;
  kind: string;
  variants: unknown[];
}

type AbiEntry = AbiFunction | AbiInterface | AbiImpl | AbiEvent;

interface ContractClass {
  abi: AbiEntry[];
  sierra_program?: unknown[];
  contract_class_version?: string;
}

// Cairo type to TypeScript type mapping
function cairoTypeToTs(cairoType: string): string {
  const typeMap: Record<string, string> = {
    "core::felt252": "string",
    "core::integer::u8": "number",
    "core::integer::u16": "number",
    "core::integer::u32": "number",
    "core::integer::u64": "bigint",
    "core::integer::u128": "bigint",
    "core::integer::u256": "bigint",
    "core::integer::i8": "number",
    "core::integer::i16": "number",
    "core::integer::i32": "number",
    "core::integer::i64": "bigint",
    "core::integer::i128": "bigint",
    "core::bool": "boolean",
    "core::starknet::contract_address::ContractAddress": "string",
    "core::starknet::class_hash::ClassHash": "string",
    "core::bytes_31::bytes31": "string",
  };

  // Handle array types
  if (cairoType.startsWith("core::array::Array<")) {
    const innerType = cairoType.slice(19, -1);
    return `${cairoTypeToTs(innerType)}[]`;
  }

  // Handle Option types
  if (cairoType.startsWith("core::option::Option<")) {
    const innerType = cairoType.slice(21, -1);
    return `${cairoTypeToTs(innerType)} | undefined`;
  }

  return typeMap[cairoType] || "string";
}

// Generate TypeScript interface for a function
function generateFunctionType(fn: AbiFunction): string {
  const inputTypes = fn.inputs
    .map((i) => `${i.name}: ${cairoTypeToTs(i.type)}`)
    .join(", ");

  const outputType =
    fn.outputs.length === 0
      ? "void"
      : fn.outputs.length === 1
        ? cairoTypeToTs(fn.outputs[0].type)
        : `[${fn.outputs.map((o) => cairoTypeToTs(o.type)).join(", ")}]`;

  return `(${inputTypes}): Promise<${outputType}>`;
}

// Generate the provider class
function generateProvider(
  contractName: string,
  interfaces: AbiInterface[]
): string {
  const allFunctions = interfaces.flatMap((i) => i.items);
  const viewFunctions = allFunctions.filter(
    (f) => f.state_mutability === "view"
  );
  const externalFunctions = allFunctions.filter(
    (f) => f.state_mutability === "external"
  );

  // Generate interface
  const interfaceLines: string[] = [];
  for (const fn of allFunctions) {
    interfaceLines.push(`  ${fn.name}${generateFunctionType(fn)};`);
  }

  // Generate implementation
  const methodLines: string[] = [];

  for (const fn of viewFunctions) {
    const args = fn.inputs.map((i) => i.name).join(", ");
    const callArgs = fn.inputs.map((i) => i.name);
    const returnType = fn.outputs.length === 0 ? "void" : fn.outputs.length === 1 ? cairoTypeToTs(fn.outputs[0].type) : `[${fn.outputs.map((o) => cairoTypeToTs(o.type)).join(", ")}]`;
    methodLines.push(`
  async ${fn.name}(${fn.inputs.map((i) => `${i.name}: ${cairoTypeToTs(i.type)}`).join(", ")}): Promise<${returnType}> {
    // starknet.js v9: call method directly on contract
    const result = await this.contract.${fn.name}(${callArgs.join(", ")});
    return result as ${returnType};
  }`);
  }

  for (const fn of externalFunctions) {
    const args = fn.inputs.map((i) => i.name).join(", ");
    const callArgs = fn.inputs.map((i) => i.name);
    methodLines.push(`
  async ${fn.name}(${fn.inputs.map((i) => `${i.name}: ${cairoTypeToTs(i.type)}`).join(", ")}): Promise<void> {
    // starknet.js v9: call method directly on contract
    const { transaction_hash } = await this.contract.${fn.name}(${callArgs.join(", ")});
    await this.provider.waitForTransaction(transaction_hash);
  }`);
  }

  return `// Auto-generated TypeScript bindings for ${contractName}
// Generated by: tools/ts-bindings/generate.ts

import { Contract, Provider, Account, RpcProvider } from "starknet";

export interface I${contractName} {
${interfaceLines.join("\n")}
}

export class ${contractName}Provider implements I${contractName} {
  private contract: Contract;
  private provider: Provider;

  constructor(
    contractAddress: string,
    abi: any[],
    providerOrAccount: Provider | Account
  ) {
    this.provider = providerOrAccount instanceof Account
      ? providerOrAccount
      : providerOrAccount;
    // starknet.js v9+ uses options object
    this.contract = new Contract({ abi, address: contractAddress, providerOrAccount });
  }

  static fromAddress(
    contractAddress: string,
    abi: any[],
    rpcUrl: string
  ): ${contractName}Provider {
    const provider = new RpcProvider({ nodeUrl: rpcUrl });
    return new ${contractName}Provider(contractAddress, abi, provider);
  }

  static withAccount(
    contractAddress: string,
    abi: any[],
    account: Account
  ): ${contractName}Provider {
    return new ${contractName}Provider(contractAddress, abi, account);
  }

  getContract(): Contract {
    return this.contract;
  }
${methodLines.join("\n")}
}
`;
}

// Generate the ABI export
function generateAbiExport(contractName: string, abi: AbiEntry[]): string {
  return `// Auto-generated ABI export for ${contractName}
// Generated by: tools/ts-bindings/generate.ts

export const ${contractName}Abi = ${JSON.stringify(abi, null, 2)} as const;
`;
}

// Main function
function main() {
  const args = process.argv.slice(2);

  if (args.length < 1) {
    console.error(
      "Usage: bun run generate.ts <contract_class.json> [output_dir]"
    );
    process.exit(1);
  }

  const inputPath = args[0];
  const outputDir = args[1] || "./bindings";

  // Read contract class
  console.log(`Reading contract class from: ${inputPath}`);
  const contractClass: ContractClass = JSON.parse(
    readFileSync(inputPath, "utf-8")
  );

  // Extract contract name from filename
  const filename = basename(inputPath, ".contract_class.json");
  const parts = filename.split("_");
  const contractName = parts[parts.length - 1] || "Contract";

  console.log(`Contract name: ${contractName}`);
  console.log(`ABI entries: ${contractClass.abi.length}`);

  // Extract interfaces
  const interfaces = contractClass.abi.filter(
    (entry): entry is AbiInterface => entry.type === "interface"
  );

  console.log(`Interfaces found: ${interfaces.length}`);

  for (const iface of interfaces) {
    console.log(`  - ${iface.name}: ${iface.items.length} functions`);
  }

  // Create output directory
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Generate provider
  const providerCode = generateProvider(contractName, interfaces);
  const providerPath = join(outputDir, `${contractName}Provider.ts`);
  writeFileSync(providerPath, providerCode);
  console.log(`Generated: ${providerPath}`);

  // Generate ABI export
  const abiCode = generateAbiExport(contractName, contractClass.abi);
  const abiPath = join(outputDir, `${contractName}Abi.ts`);
  writeFileSync(abiPath, abiCode);
  console.log(`Generated: ${abiPath}`);

  // Generate index file
  const indexCode = `// Auto-generated index for ${contractName}
export * from "./${contractName}Provider";
export * from "./${contractName}Abi";
`;
  const indexPath = join(outputDir, "index.ts");
  writeFileSync(indexPath, indexCode);
  console.log(`Generated: ${indexPath}`);

  console.log("\nDone! Generated files:");
  console.log(`  - ${providerPath}`);
  console.log(`  - ${abiPath}`);
  console.log(`  - ${indexPath}`);
}

main();
